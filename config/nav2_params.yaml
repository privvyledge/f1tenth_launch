bt_navigator:
  ros__parameters:
    use_sim_time: False
    global_frame: map
    robot_base_frame: base_link
    odom_frame: odom
    odom_topic: /odometry/local # /odom
    bt_loop_duration: 10
    default_server_timeout: 20
    # 'default_nav_through_poses_bt_xml' and 'default_nav_to_pose_bt_xml' are use defaults:
    # nav2_bt_navigator/navigate_to_pose_w_replanning_and_recovery.xml
    # nav2_bt_navigator/navigate_through_poses_w_replanning_and_recovery.xml
    # They can be set here or via a RewrittenYaml remap from a parent launch file to Nav2.
#    enable_groot_monitoring: True
#    groot_zmq_publisher_port: 1666
#    groot_zmq_server_port: 1667
#    default_bt_xml_filename: "navigate_w_replanning_time.xml"
#    # navigate_w_replanning_time.xml
#    # navigate_w_replanning_distance.xml
#    # navigate_w_replanning_speed.xml
#    # navigate_w_replanning_and_recovery.xml
#    # navigate_w_replanning_and_round_robin_recovery.xml
    plugin_lib_names:
      - nav2_compute_path_to_pose_action_bt_node
      - nav2_compute_path_through_poses_action_bt_node
      - nav2_smooth_path_action_bt_node
      - nav2_follow_path_action_bt_node
      - nav2_spin_action_bt_node
      - nav2_wait_action_bt_node
      - nav2_assisted_teleop_action_bt_node
      - nav2_back_up_action_bt_node
      - nav2_drive_on_heading_bt_node
      - nav2_clear_costmap_service_bt_node
      - nav2_is_stuck_condition_bt_node
      - nav2_goal_reached_condition_bt_node
      - nav2_goal_updated_condition_bt_node
      - nav2_globally_updated_goal_condition_bt_node
      - nav2_is_path_valid_condition_bt_node
      - nav2_initial_pose_received_condition_bt_node
      - nav2_reinitialize_global_localization_service_bt_node
      - nav2_rate_controller_bt_node
      - nav2_distance_controller_bt_node
      - nav2_speed_controller_bt_node
      - nav2_truncate_path_action_bt_node
      - nav2_truncate_path_local_action_bt_node
      - nav2_goal_updater_node_bt_node
      - nav2_recovery_node_bt_node
      - nav2_pipeline_sequence_bt_node
      - nav2_round_robin_node_bt_node
      - nav2_transform_available_condition_bt_node
      - nav2_time_expired_condition_bt_node
      - nav2_path_expiring_timer_condition
      - nav2_distance_traveled_condition_bt_node
      - nav2_single_trigger_bt_node
      - nav2_goal_updated_controller_bt_node
      - nav2_is_battery_low_condition_bt_node
      - nav2_navigate_through_poses_action_bt_node
      - nav2_navigate_to_pose_action_bt_node
      - nav2_remove_passed_goals_action_bt_node
      - nav2_planner_selector_bt_node
      - nav2_controller_selector_bt_node
      - nav2_goal_checker_selector_bt_node
      - nav2_controller_cancel_bt_node
      - nav2_path_longer_on_approach_bt_node
      - nav2_wait_cancel_bt_node
      - nav2_spin_cancel_bt_node
      - nav2_back_up_cancel_bt_node
      - nav2_assisted_teleop_cancel_bt_node
      - nav2_drive_on_heading_cancel_bt_node
      - nav2_is_battery_charging_condition_bt_node

bt_navigator_navigate_through_poses_rclcpp_node:
  ros__parameters:
    use_sim_time: False

bt_navigator_navigate_to_pose_rclcpp_node:
  ros__parameters:
    use_sim_time: False

# note: Foxy RPP does not support reversing.
controller_server:
  ros__parameters:
    use_sim_time: False
    controller_frequency: 20.0
    min_x_velocity_threshold: 0.01 # 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.01  # 0.001
    failure_tolerance: 0.0 # -1.0 makes it infinite, 0 to disable, and any positive value (0.3) for the appropriate timeout
    odom_topic: "/odometry/local"
    progress_checker_plugins: "progress_checker" # "progress_checker" for Humble and older, ["progress_checker"] otherwise
    goal_checker_plugins: ["goal_checker"] # "precise_goal_checker" or "general_goal_checker" for Humble and older, ["general_goal_checker"], ["precise_goal_checker"] otherwise
    controller_plugins: ["FollowPath"]

    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5
      movement_time_allowance: 20.0 # 10.0

    # Goal checker parameters
    #precise_goal_checker:
    #  plugin: "nav2_controller::SimpleGoalChecker"
    #  xy_goal_tolerance: 0.25
    #  yaw_goal_tolerance: 0.25
    #  stateful: True
    goal_checker:  # general_goal_checker
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.25 # 0.5, 0.25
      yaw_goal_tolerance: 0.25 # 0.5, 0.25
      stateful: True

    ## Controller paramaters
    # Regulated Pure Pursuit (https://navigation.ros.org/configuration/packages/configuring-regulated-pp.html | https://github.com/ros-planning/navigation2/tree/foxy-devel/nav2_regulated_pure_pursuit_controller)
    # MPPI (https://github.com/ros-planning/navigation2/tree/humble/nav2_mppi_controller | https://navigation.ros.org/configuration/packages/configuring-mppic.html)
    FollowPath:
      # Valid ackermann plugins: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController", "nav2_mppi_controller::MPPIController"
      plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"

      # Common parameters (common to RPP and MPPI)
      transform_tolerance: 0.2 # 0.1, 1.0

      # Pure Pursuit Parameters
      desired_linear_vel: 0.5 # 0.5, 1.0
      max_linear_accel: 2.0  # 2.0, 3.0
      max_linear_decel: 2.0  # 2.0, 3.0
      max_angular_accel: 3.0
      lookahead_dist: 0.6 # 0.4, 0.6, 1.5
      min_lookahead_dist: 0.3 # 0.1, 0.3
      max_lookahead_dist: 3.0 # 0.9, 3.0, 7.0
      lookahead_time: 1.5
      rotate_to_heading_angular_vel: 1.8
      use_velocity_scaled_lookahead_dist: false # true, false
      min_approach_linear_velocity: 0.05
      approach_velocity_scaling_dist: 1.0 # 0.6
      use_approach_linear_velocity_scaling: false
      use_collision_detection: true
      max_allowed_time_to_collision_up_to_carrot: 1.0
      use_regulated_linear_velocity_scaling: false # true
      use_fixed_curvature_lookahead: true # false
      curvature_lookahead_dist: 1.0 # 0.25
      use_cost_regulated_linear_velocity_scaling: false # true, false
      regulated_linear_scaling_min_radius: 0.9
      regulated_linear_scaling_min_speed: 0.25
      use_rotate_to_heading: false
      allow_reversing: true # false
      rotate_to_heading_min_angle: 0.785
      max_robot_pose_search_dist: 10.0
      use_interpolation: false
      goal_dist_tol: 0.25
      cost_scaling_dist: 0.3
      cost_scaling_gain: 1.0
      inflation_cost_scaling_factor: 3.0

      # MPPI Parameters
      time_steps: 56 # horizon
      model_dt: 0.05  # sample time, i.e prediction_time = time_steps * model_dt
      batch_size: 2000  # 1000 @ 50 Hz or 2000 @ 30 Hz
      vx_std: 0.2
      vy_std: 0.2
      wz_std: 0.4
      vx_max: 0.75
      vx_min: -0.75
      vy_max: 0.5
      wz_max: 1.9
      iteration_count: 1
      prune_distance: 1.7
      temperature: 0.3
      gamma: 0.015
      motion_model: "Ackermann"
      visualize: true  # false
      retry_attempt_limit: 3
      TrajectoryVisualizer:
        trajectory_step: 5
        time_step: 3
      AckermannConstraints:
        min_turning_r: 0.462  # WB/tan(max_steer), e.g 0.256 / math.tan(math.radians(30))
      critics: [ "ConstraintCritic", "ObstaclesCritic", "GoalCritic", "GoalAngleCritic", "PathAlignCritic", "PathFollowCritic", "PathAngleCritic", "PreferForwardCritic" ]
      ConstraintCritic:
        enabled: true
        cost_power: 1
        cost_weight: 4.0
      GoalCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0
        threshold_to_consider: 1.4
      GoalAngleCritic:
        enabled: true
        cost_power: 1
        cost_weight: 3.0
        threshold_to_consider: 0.5
      PreferForwardCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0
        threshold_to_consider: 0.5
      ObstaclesCritic:
        enabled: true
        cost_power: 1
        repulsion_weight: 1.5
        critical_weight: 20.0
        consider_footprint: false
        collision_cost: 10000.0
        collision_margin_distance: 0.1
        near_goal_distance: 0.5
      PathAlignCritic:
        enabled: true
        cost_power: 1
        cost_weight: 14.0
        max_path_occupancy_ratio: 0.05
        trajectory_point_step: 3
        threshold_to_consider: 0.5
        offset_from_furthest: 20
        use_path_orientations: false
      PathFollowCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0
        offset_from_furthest: 5
        threshold_to_consider: 1.4
      PathAngleCritic:
        enabled: true
        cost_power: 1
        cost_weight: 2.0
        offset_from_furthest: 4
        threshold_to_consider: 0.5
        max_angle_to_furthest: 1.0
        forward_preference: true
      # TwirlingCritic:
      #   enabled: true
      #   twirling_cost_power: 1
      #   twirling_cost_weight: 10.0


controller_server_rclcpp_node:
  ros__parameters:
    use_sim_time: False

# todo: (optionally) remove plugins from local costmap
# add denoising to costmaps: https://navigation.ros.org/configuration/packages/costmap-plugins/denoise.html
local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 20.0
      publish_frequency: 20.0
      global_frame: odom
      robot_base_frame: base_link
#      map_topic: /map  # defaults to topic set in global if commented
      use_sim_time: False
      rolling_window: true
      width: 10
      height: 10
      resolution: 0.05
      footprint: "[ [0.3302, 0.1016], [0.3302, -0.1016], [0.0, -0.1016], [0.0, 0.1016] ]"
      footprint_padding: 0.08  # 0.03
      robot_radius: 0.22
      plugins: ["voxel_layer", "inflation_layer"]
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 1.5  # 3.0
        inflation_radius: 0.1  # 0.1, 0.55
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: True
        publish_voxel_map: True
        origin_z: 0.0
        z_resolution: 0.05
        z_voxels: 16
        max_obstacle_height: 2.0
        mark_threshold: 0
        observation_sources: scan
        scan:
          topic: /lidar/scan_filtered
          max_obstacle_height: 10.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 12.0  # 3.0. Raytrace range should be higher than obstacle range
          raytrace_min_range: 0.0
          obstacle_max_range: 10.0 # 2.5
          obstacle_min_range: 0.0
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
        enabled: true
        subscribe_to_updates: true
        transform_tolerance: 1.0 # 0.1
      always_send_full_costmap: True
#  local_costmap_client:
#    ros__parameters:
#      use_sim_time: False
#  local_costmap_rclcpp_node:
#    ros__parameters:
#      use_sim_time: False

# todo: add stvl layer (https://answers.ros.org/question/346886/clear-obstacles-of-obstacle-layer-of-costmap/)
global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 10.0
      publish_frequency: 10.0
      global_frame: map
      robot_base_frame: base_link
#      map_topic: map
      use_sim_time: False
      footprint: "[ [0.3302, 0.1016], [0.3302, -0.1016], [0.0, -0.1016], [0.0, 0.1016] ]"
#      robot_radius: 0.22
      rolling_window: false
      footprint_padding: 0.08  # 0.03
      resolution: 0.05
      track_unknown_space: false # true
      plugins: ["static_layer", "obstacle_layer", "voxel_layer", "inflation_layer"]  # obstacle_layer: 2d, voxel_layer: 3d
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
        enabled: true
        subscribe_to_updates: true
        transform_tolerance: 1.0 # 0.1
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: scan #pointcloud
        footprint_clearing_enabled: true
        max_obstacle_height: 4.0  # 2.0
        combination_method: 1
        scan:
          topic: /lidar/scan_filtered
          obstacle_max_range: 10.0 # 30.0
          obstacle_min_range: 0.0
          raytrace_max_range: 12.0 # 30.0. Raytrace range should be higher than obstacle range
          raytrace_min_range: 0.0
          max_obstacle_height: 10.0
          min_obstacle_height: 0.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          inf_is_valid: false  # todo: check for all sensors and set to true if inf exists
          expected_update_rate: 0.2  # 0.1 (average rate for YDLidar is 8.626 Hz or 0.1159285880s) so give more tolerance
          observation_persistence: 0.5
#        pointcloud:
#          topic: /camera/depth/color/points  # todo: pass from launch file (/camera/depth/color/points, /camera/cloud_from_depth, )
#          max_obstacle_height: 2.0
#          min_obstacle_height: 0.05
#          obstacle_max_range: 5.0
#          obstacle_min_range: 0.0
#          raytrace_max_range: 5.0
#          raytrace_min_range: 0.0
#          clearing: True
#          marking: True
#          data_type: "PointCloud2"
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: True
        footprint_clearing_enabled: true
        max_obstacle_height: 2.0
        publish_voxel_map: True
        origin_z: 0.0
        z_resolution: 0.05
        z_voxels: 16
        unknown_threshold: 15
        mark_threshold: 0
        observation_sources: scan pointcloud pointcloud_clearing
        combination_method: 1
        scan:
          topic: /scan/depth_image
          obstacle_max_range: 4.0 #
          obstacle_min_range: 0.0
          raytrace_max_range: 5.0 # Raytrace range should be higher than obstacle range
          raytrace_min_range: 0.0
          max_obstacle_height: 2.0
          min_obstacle_height: 0.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          inf_is_valid: false  # todo: check for all sensors and set to true if inf exists
          expected_update_rate: 0.2  # 0.1 (average rate for laserscan from realsense depthimage is 16 Hz or 0.0625s) so give more tolerance
          observation_persistence: 0.5
        pointcloud: # no frame set, uses frame from message
          topic: /camera/downsampled_cloud_from_depth  # (/camera/downsampled_cloud_from_depth | /camera/obstacles_from_cloud | /camera/depth/color/points) todo: pass from launch file (/camera/depth/color/points, /camera/cloud_from_depth, )
          max_obstacle_height: 2.0
          min_obstacle_height: 0.1
          obstacle_max_range: 4.0
          obstacle_min_range: 0.0
          raytrace_max_range: 5.0  # raytrace range shoulg be higher than obstacle range
          raytrace_min_range: 0.0
          expected_update_rate: 2.0
          clearing: False
          marking: True  # to insert valid obstacles "min_obstacle_height" above the  ground
          data_type: "PointCloud2"
          publish_voxel_map: False  # to visualize voxels in Rviz
          observation_persistence: 0.5
        pointcloud_clearing:
          topic: /camera/downsampled_cloud_from_depth  # todo: use ground/obstacle pointcloud (/camera/downsampled_cloud_from_depth | /camera/obstacles_from_cloud | /camera/depth/color/points) todo: pass from launch file (/camera/depth/color/points, /camera/cloud_from_depth, )
          max_obstacle_height: 0.5
          min_obstacle_height: 0.0  # or -1.0
          obstacle_max_range: 4.0
          obstacle_min_range: 0.0
          raytrace_max_range: 5.0  # raytrace range shoulg be higher than obstacle range
          raytrace_min_range: 0.0
          expected_update_rate: 2.0
          clearing: True  # to clear the ground
          marking: False
          data_type: "PointCloud2"
          publish_voxel_map: False  # to visualize voxels in Rviz
          observation_persistence: 0.5
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        enabled: true
        cost_scaling_factor: 1.5 # 3.0, 1.0
        inflation_radius: 0.1 # 0.1, 0.55
        inflate_around_unknown: true
      always_send_full_costmap: True
#  global_costmap_client:
#    ros__parameters:
#      use_sim_time: False
#  global_costmap_rclcpp_node:
#    ros__parameters:
#      use_sim_time: False

#map_server:
#  ros__parameters:
#    use_sim_time: False
#    yaml_filename: "turtlebot3_world.yaml"

#map_saver:
#  ros__parameters:
#    use_sim_time: False
#    save_map_timeout: 5000
#    free_thresh_default: 0.25
#    occupied_thresh_default: 0.65
#    map_subscribe_transient_local: True

# Note: Foxy DUBIN does not support reversing
planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    planner_plugins: ["GridBased"]
    use_sim_time: False

    GridBased:
      plugin: "nav2_smac_planner/SmacPlannerHybrid"
      tolerance: 0.5                    # tolerance for planning if unable to reach exact pose, in meters, for 2D node
      downsample_costmap: false         # (false) whether or not to downsample the map
      downsampling_factor: 2            # (1) multiplier for the resolution of the costmap layer (e.g. 2 on a 5cm costmap would be 10cm)
      allow_unknown: false              # (false) allow traveling in unknown space
      max_iterations: 1000000               # maximum total iterations to search for before failing
      max_on_approach_iterations: 1000  # maximum number of iterations to attempt to reach goal once in tolerance, 2D only
      max_planning_time_ms: 3.5     # max time in s for planner to plan, smooth, and upsample. Will scale maximum smoothing and upsampling times based on remaining time after planning.
      smooth_path: False                # Whether to smooth searched path
      motion_model_for_search: "DUBIN"  # FOr Hybrid Dubin, Redds-Shepp. 2D Moore, Von Neumann; SE2 Dubin ("DUBIN"), Redds-Shepp ("REEDS_SHEPP")
      cost_travel_multiplier: 2.0         # For 2D: Cost multiplier to apply to search to steer away from high cost areas. Larger values will place in the center of aisles more exactly (if non-`FREE` cost potential field exists) but take slightly longer to compute. To optimize for speed, a value of 1.0 is reasonable. A reasonable tradeoff value is 2.0. A value of 0.0 effective disables steering away from obstacles and acts like a naive binary search A*.
      angle_quantization_bins: 64       # (64, 72) For SE2 node: Number of angle bins for search, must be 1 for 2D node (no angle search)
      analytic_expansion_ratio: 3.5       # For Hybrid/Lattice nodes: The ratio to attempt analytic expansions during search for final approach.
      analytic_expansion_max_length: 3.465    # (min_turn_radius * 7.5) For Hybrid/Lattice nodes: The maximum length of the analytic expansion to be considered valid to prevent unsafe shortcutting (in meters). This should be scaled with minimum turning radius and be no less than 4-5x the minimum radius
      minimum_turning_radius: 0.462     # (1.5) For Hybrid/Lattice nodes & smoother: minimum turning radius in m of path / vehicle
      reverse_penalty: 2.1            # (2.1) For Reeds-Shepp model: penalty to apply if motion is reversing, must be => 1
      change_penalty: 0.20              # For Hybrid/Lattice nodes: penalty to apply if motion is changing directions, must be >= 0
      non_straight_penalty: 1.20        # For Hybrid/Lattice nodes: penalty to apply if motion is non-straight, must be => 1
      cost_penalty: 2.0                 # (1.3) For Hybrid/Lattice nodes: penalty to apply to higher cost zones/areas when adding into the obstacle map dynamic programming distance expansion heuristic. This drives the robot more towards the center of passages. A value between 1.3 - 3.5 is reasonable.
      retrospective_penalty: 0.025        # For Hybrid/Lattice nodes: penalty to prefer later maneuvers before earlier along the path. Saves search time since earlier nodes are not expanded until it is necessary. Must be >= 0.0 and <= 1.0
      rotation_penalty: 500.0               # (5.0) For Lattice node: Penalty to apply only to pure rotate in place commands when using minimum control sets containing rotate in place primitives. This should always be set sufficiently high to weight against this action unless strictly necessary for obstacle avoidance or there may be frequent discontinuities in the plan where it requests the robot to rotate in place to short-cut an otherwise smooth path for marginal path distance savings.
      lookup_table_size: 20.0               # For Hybrid nodes: Size of the dubin/reeds-sheep distance window to cache, in meters.
      cache_obstacle_heuristic: True      # For Hybrid nodes: Cache the obstacle map dynamic programming distance expansion heuristic between subsiquent replannings of the same goal location. Dramatically speeds up replanning performance (40x) if costmap is largely static.
      allow_reverse_expansion: False      # For Lattice nodes: Whether to expand state lattice graph in forward primitives or reverse as well, will double the branching factor at each step.

      smoother:
        max_iterations: 1000
        w_smooth: 0.3             # (30000.0) weight to maximize smoothness of path
        w_data: 0.2
        tolerance: 1e-10
        do_refinement: true               # Whether to recursively run the smoother 3 times on the results from prior runs to refine the results further
#        w_curve: 30.0                 # weight to minimize curvature of path
#        w_dist: 0.0                   # weight to bind path to original as optional replacement for cost weight
#        w_cost: 0.025                 # weight to steer robot away from collision and cost
#        cost_scaling_factor: 10.0     # this should match the inflation layer's parameter

#planner_server_rclcpp_node:
#  ros__parameters:
#    use_sim_time: False


# Constrained smoother (https://navigation.ros.org/configuration/packages/configuring-constrained-smoother.html)
smoother_server:
  ros__parameters:
    use_sim_time: False
    smoother_plugins: ["SmoothPath"]  # ["SmoothPath"], ["simple_smoother"]

    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 1.0e-10
      max_its: 1000
      do_refinement: True

    SmoothPath:
      plugin: "nav2_constrained_smoother/ConstrainedSmoother"
      reversing_enabled: true       # whether to detect forward/reverse direction and cusps. Should be set to false for paths without orientations assigned
      path_downsampling_factor: 3   # every n-th node of the path is taken. Useful for speed-up
      path_upsampling_factor: 1     # 0 - path remains downsampled, 1 - path is upsampled back to original granularity using cubic bezier, 2... - more upsampling
      keep_start_orientation: true  # whether to prevent the start orientation from being smoothed
      keep_goal_orientation: true   # whether to prevent the gpal orientation from being smoothed
      minimum_turning_radius: 0.40  # minimum turning radius the robot can perform. Can be set to 0.0 (or w_curve can be set to 0.0 with the same effect) for diff-drive/holonomic robots
      w_curve: 30.0                 # weight to enforce minimum_turning_radius
      w_dist: 0.0                   # weight to bind path to original as optional replacement for cost weight
      w_smooth: 2000000.0           # weight to maximize smoothness of path
      w_cost: 0.015                 # weight to steer robot away from collision and cost

      # Parameters used to improve obstacle avoidance near cusps (forward/reverse movement changes)
      # See the [docs page](https://navigation.ros.org/configuration/packages/configuring-constrained-smoother) for further clarification
      w_cost_cusp_multiplier: 3.0   # option to have higher weight during forward/reverse direction change which is often accompanied with dangerous rotations
      cusp_zone_length: 2.5         # length of the section around cusp in which nodes use w_cost_cusp_multiplier (w_cost rises gradually inside the zone towards the cusp point, whose costmap weight equals w_cost*w_cost_cusp_multiplier)

      # Points in robot frame to grab costmap values from. Format: [x1, y1, weight1, x2, y2, weight2, ...]
      # IMPORTANT: Requires much higher number of iterations to actually improve the path. Uncomment only if you really need it (highly elongated/asymmetric robots)
      # See the [docs page](https://navigation.ros.org/configuration/packages/configuring-constrained-smoother) for further clarification
      # cost_check_points: [-0.185, 0.0, 1.0]

      optimizer:
        max_iterations: 70            # max iterations of smoother
        debug_optimizer: false        # print debug info
        gradient_tol: 5e3
        fn_tol: 1.0e-15
        param_tol: 1.0e-20

behavior_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    behavior_plugins: ["backup", "drive_on_heading", "assisted_teleop", "wait"]  # ["spin", "backup", "drive_on_heading", "assisted_teleop", "wait"]
#    spin:
#      plugin: "nav2_behaviors/Spin"
    backup:
      plugin: "nav2_behaviors/BackUp"
    drive_on_heading:
      plugin: "nav2_behaviors/DriveOnHeading"
    wait:
      plugin: "nav2_behaviors/Wait"
    assisted_teleop:
      plugin: "nav2_behaviors/AssistedTeleop"
    global_frame: odom
    robot_base_frame: base_link
    transform_tolerance: 0.1
    use_sim_time: false
    simulate_ahead_time: 2.0
    max_rotational_vel: 1.0
    min_rotational_vel: 0.4
    rotational_acc_lim: 3.2

robot_state_publisher:
  ros__parameters:
    use_sim_time: False

waypoint_follower:
  ros__parameters:
    use_sim_time: False
    loop_rate: 20
    stop_on_failure: false
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: True
      waypoint_pause_duration: 200

# See (https://navigation.ros.org/configuration/packages/configuring-velocity-smoother.html)
velocity_smoother:
  ros__parameters:
    use_sim_time: False
    smoothing_frequency: 20.0
    scale_velocities: false  # scale velocities proportionally if any axis is outside of acceleration range to follow same vector, if possible
    feedback: "OPEN_LOOP"  # Type of feedback for current speed. Open loop uses the last smoothed output. Closed loop uses robot odometry
    max_velocity: [1.0, 0.0, 3.0]  # Maximum velocities, ordered [Vx, Vy, Vw]
    min_velocity: [-1.0, 0.0, -3.0]  # Minimum velocities, ordered [Vx, Vy, Vw]
    deadband_velocity: [0.3, 0.0, 0.0]  # A deadband of velocities below which they should be zero-ed out for sending to the robot base controller, ordered [Vx, Vy, Vw]
    velocity_timeout: 1.0  # Time (s) after which if no new velocity commands are received to zero out and stop
    max_accel: [3.0, 0.0, 2.0] # Maximum acceleration, ordered [Ax, Ay, Aw]
    max_decel: [-3.0, 0.0, -2.0]  # Maximum deceleration, ordered [Ax, Ay, Aw]
    odom_topic: "/odometry/local"  # Topic of odometry to use for estimating current velocities
    odom_duration: 0.1  # Period of time (s) to sample odometry information in for velocity estimation